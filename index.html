
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <meta
            name="Projet ZZ1 BALLEJOS CORNUEZ LEGER"
            content="Documentation for the Kittn API"
        >
    <title>Projet ZZ1 Groupe 31</title>

    <style media="screen">
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .nl {
  color: #f92672;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <style media="print">
      * {
        -webkit-transition:none!important;
        transition:none!important;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #586e75;
}
.highlight .err {
  color: #002b36;
  background-color: #dc322f;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cm, .highlight .cpf, .highlight .c1, .highlight .cs {
  color: #657b83;
}
.highlight .cp {
  color: #b58900;
}
.highlight .nt {
  color: #b58900;
}
.highlight .o, .highlight .ow {
  color: #93a1a1;
}
.highlight .p, .highlight .pi {
  color: #93a1a1;
}
.highlight .gi {
  color: #859900;
}
.highlight .gd {
  color: #dc322f;
}
.highlight .gh {
  color: #268bd2;
  background-color: #002b36;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #6c71c4;
}
.highlight .kc {
  color: #cb4b16;
}
.highlight .kt {
  color: #cb4b16;
}
.highlight .kd {
  color: #cb4b16;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .dl, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #859900;
}
.highlight .sa {
  color: #6c71c4;
}
.highlight .sr {
  color: #2aa198;
}
.highlight .si {
  color: #d33682;
}
.highlight .se {
  color: #d33682;
}
.highlight .nn {
  color: #b58900;
}
.highlight .nc {
  color: #b58900;
}
.highlight .no {
  color: #b58900;
}
.highlight .na {
  color: #268bd2;
}
.highlight .m, .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mx {
  color: #859900;
}
.highlight .ss {
  color: #859900;
}
    </style>
    <link href="stylesheets/screen-c9d8fa83.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-953e3353.css" rel="stylesheet" media="print" />
      <script src="javascripts/all_nosearch-18c3ed8e.js"></script>

  </head>

  <body class="index" data-languages="[&quot;c&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo-b043c49a.png" class="logo" alt="" />
        <div class="lang-selector">
              <a href="#" data-language-name="c">c</a>
        </div>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#accueil" class="toc-h1 toc-link" data-title="Accueil">Accueil</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#membres-du-groupe-31" class="toc-h2 toc-link" data-title="Membres du Groupe 31">Membres du Groupe 31</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#hebergement-du-projet" class="toc-h1 toc-link" data-title="Hébergement du projet">Hébergement du projet</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#les-programmes" class="toc-h2 toc-link" data-title="Les programmes">Les programmes</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#todo-list" class="toc-h1 toc-link" data-title="TODO List">TODO List</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#fonctionnement" class="toc-h2 toc-link" data-title="Fonctionnement">Fonctionnement</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#xfenetre" class="toc-h1 toc-link" data-title="Xfenetré">Xfenetré</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#ballejos-lilian" class="toc-h2 toc-link" data-title="BALLEJOS Lilian">BALLEJOS Lilian</a>
                  </li>
                  <li>
                    <a href="#leger-bertrand" class="toc-h2 toc-link" data-title="LEGER Bertrand">LEGER Bertrand</a>
                  </li>
                  <li>
                    <a href="#cornuez-charlotte" class="toc-h2 toc-link" data-title="CORNUEZ Charlotte">CORNUEZ Charlotte</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#animation-forme" class="toc-h1 toc-link" data-title="Animation Forme">Animation Forme</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#ballejos-lilian-2" class="toc-h2 toc-link" data-title="BALLEJOS Lilian">BALLEJOS Lilian</a>
                  </li>
                  <li>
                    <a href="#cornuez-charlotte-2" class="toc-h2 toc-link" data-title="CORNUEZ Charlotte">CORNUEZ Charlotte</a>
                  </li>
                  <li>
                    <a href="#leger-bertrand-2" class="toc-h2 toc-link" data-title="LEGER Bertrand">LEGER Bertrand</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#animation-avec-texture" class="toc-h1 toc-link" data-title="Animation avec Texture">Animation avec Texture</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#ballejos-lilian-3" class="toc-h2 toc-link" data-title="BALLEJOS Lilian">BALLEJOS Lilian</a>
                  </li>
                  <li>
                    <a href="#leger-bertrand-3" class="toc-h2 toc-link" data-title="LEGER Bertrand">LEGER Bertrand</a>
                  </li>
                  <li>
                    <a href="#cornuez-charlotte-3" class="toc-h2 toc-link" data-title="CORNUEZ Charlotte">CORNUEZ Charlotte</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#jeu-de-la-vie" class="toc-h1 toc-link" data-title="Jeu de la vie">Jeu de la vie</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#principe-implemente" class="toc-h2 toc-link" data-title="Principe implémenté">Principe implémenté</a>
                  </li>
                  <li>
                    <a href="#probleme-rencontre" class="toc-h2 toc-link" data-title="Problème rencontré">Problème rencontré</a>
                  </li>
                  <li>
                    <a href="#video-10" class="toc-h2 toc-link" data-title="Video">Video</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#chef-d-39-oeuvre" class="toc-h1 toc-link" data-title="Chef d'oeuvre">Chef d'oeuvre</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#presentation" class="toc-h2 toc-link" data-title="Présentation">Présentation</a>
                  </li>
                  <li>
                    <a href="#video-11" class="toc-h2 toc-link" data-title="Vidéo">Vidéo</a>
                  </li>
                  <li>
                    <a href="#a-ameliorer" class="toc-h2 toc-link" data-title="A améliorer">A améliorer</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#jeu-avec-apprentissage-par-renforcement" class="toc-h1 toc-link" data-title="Jeu avec apprentissage par renforcement">Jeu avec apprentissage par renforcement</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#presentation-2" class="toc-h2 toc-link" data-title=" Présentation"> Présentation</a>
                  </li>
                  <li>
                    <a href="#amelioration-de-la-partie-graphique-et-du-quot-gameplay-quot" class="toc-h2 toc-link" data-title="Amélioration de la partie graphique et du "GamePlay"">Amélioration de la partie graphique et du "GamePlay"</a>
                  </li>
                  <li>
                    <a href="#apprentissage-par-renforcement-n-1" class="toc-h2 toc-link" data-title="Apprentissage par renforcement n°1">Apprentissage par renforcement n°1</a>
                  </li>
                  <li>
                    <a href="#apprentissage-par-renforcement-n-2" class="toc-h2 toc-link" data-title="Apprentissage par renforcement n°2">Apprentissage par renforcement n°2</a>
                  </li>
              </ul>
          </li>
      </ul>
        <ul class="toc-footer">
            <li>Projet ZZ1</li>
            <li>BALLEJOS Lilian</li>
            <li>CORNUEZ Charlotte</li>
            <li>LEGER Bertrand</li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='accueil'>Accueil</h1><h2 id='membres-du-groupe-31'>Membres du Groupe 31</h2>
<p>Bienvenue sur le site web des membres du groupe 31 du Projet ZZ1 2022, nous sommes :</p>

<ul>
<li>BALLEJOS Lilian</li>
<li>CORNUEZ Charlotte</li>
<li>LEGER Bertrand</li>
</ul>
<h1 id='hebergement-du-projet'>Hébergement du projet</h1><h2 id='les-programmes'>Les programmes</h2>
<p>Les programmes se trouvent tous dans le GitLab ISIMA de BALLEJOS Lilian à ce lien: <a href="https://gitlab.isima.fr/liballejos/projetzz1">ici</a></p>

<p>Tous les programmes <strong>à jours</strong> sont dans la branche <strong>MASTER</strong></p>
<h1 id='todo-list'>TODO List</h1><h2 id='fonctionnement'>Fonctionnement</h2>
<p>Vous trouverez ici le programme de tout ce que l&#39;on va faire durant ces 2 semaines jour par jour</p>
<h3 id='20-06-22-lundi'>20/06/22 (Lundi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian</td>
<td>Mise en place du site</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Mise en place d&#39;un GitLab organisé</td>
</tr>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian</td>
<td>Xfenetré</td>
</tr>
<tr>
<td>✔️</td>
<td>LEGER BERTRAND</td>
<td>Xfenetré</td>
</tr>
<tr>
<td>✔️</td>
<td>CORNUEZ Charlotte</td>
<td>Xfenetré</td>
</tr>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian</td>
<td>Animation Forme</td>
</tr>
</tbody></table>
<h3 id='21-06-22-mardi'>21/06/22 (Mardi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Répartition tâches jeu de la vie</td>
</tr>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian</td>
<td>Animation avec Texture</td>
</tr>
<tr>
<td>✔️</td>
<td>LEGER Bertrand</td>
<td>Animation Forme</td>
</tr>
<tr>
<td>✔️</td>
<td>CORNUEZ Charlotte</td>
<td>Animation Forme</td>
</tr>
<tr>
<td>✔️</td>
<td>CORNUEZ CHarlotte</td>
<td>Animation avec Texture</td>
</tr>
<tr>
<td>✔️</td>
<td>LEGER Bertrand</td>
<td>Animation avec Texture</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Commencement du Jeu de la vie</td>
</tr>
</tbody></table>
<h3 id='21-06-22-mercredi'>21/06/22 (Mercredi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Finalisation du Jeu de la vie</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Répartition des tâches du &quot;Premier Chef d&#39;Oeuvre&quot;</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Commencement du premier Chef d&#39;Oeuvre</td>
</tr>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian</td>
<td>Mise à jour du site en prévision de vendredi</td>
</tr>
</tbody></table>
<h3 id='22-06-22-jeudi'>22/06/22 (Jeudi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian</td>
<td>Remplissage du site pour la présentation de vendredi</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Finalisation du Chef d&#39;Oeuvre</td>
</tr>
</tbody></table>
<h3 id='23-06-22-vendredi'>23/06/22 (Vendredi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Soutenance</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Recherche sur l&#39;apprentissage par renforcement</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Répartition des tâches pour le jeu avec apprentissage par renforcement</td>
</tr>
</tbody></table>
<h3 id='27-06-22-lundi'>27/06/22 (Lundi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian &amp; CORNUEZ Charlotte</td>
<td>Amélioration de l&#39;animation du jeu</td>
</tr>
<tr>
<td>✔️</td>
<td>LEGER Bertrand</td>
<td>Commencement de l&#39;apprentissage</td>
</tr>
</tbody></table>
<h3 id='28-06-22-mardi'>28/06/22 (Mardi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian</td>
<td>Création d&#39;un menu</td>
</tr>
<tr>
<td>✔️</td>
<td>LEGER Bertrand</td>
<td>Ecriture du code d&#39;exploration</td>
</tr>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian &amp; CORNUEZ Charlotte</td>
<td>Ecriture du code d&#39;exploitation</td>
</tr>
</tbody></table>
<h3 id='29-06-22-mercredi'>29/06/22 (Mercredi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Mise en commun des différents codes</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Débugage du code</td>
</tr>
</tbody></table>
<h3 id='30-06-22-jeudi'>30/06/22 (Jeudi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>BALLEJOS Lilian &amp; LEGER Bertrand</td>
<td>Débugage du code</td>
</tr>
<tr>
<td>✔️</td>
<td>CORNUEZ Charlotte</td>
<td>Mise à jour du site</td>
</tr>
</tbody></table>
<h3 id='1-07-22-vendredi'>1/07/22 (Vendredi)</h3>
<table><thead>
<tr>
<th>Avancé</th>
<th>Membre</th>
<th>Tâche</th>
</tr>
</thead><tbody>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Finalisation du code et du site</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Nettoyage et &quot;Commentation&quot; du code</td>
</tr>
<tr>
<td>✔️</td>
<td>Commun</td>
<td>Soutenance</td>
</tr>
</tbody></table>
<h1 id='xfenetre'>Xfenetré</h1><h2 id='ballejos-lilian'>BALLEJOS Lilian</h2><h3 id='explication-et-code'>Explication et Code</h3>
<p>Mise en place d&#39;un programme qui récupère les dimensions de l&#39;écran principal et crée une animation de sinusoïde avec les fenêtres générées.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="cm">/*Taille ecran*/</span>

  <span class="n">SDL_DisplayMode</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">SDL_GetCurrentDisplayMode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">h</span><span class="p">;</span>
  <span class="c1">//printf("%d %d\n", width, height);</span>
  <span class="kt">int</span> <span class="n">milieu</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">TAILLE_FENETRE</span><span class="p">;</span> <span class="c1">// milieu ecran axe y</span>
  <span class="kt">int</span> <span class="n">nbr_element</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="n">TAILLE_FENETRE</span><span class="p">;</span> <span class="c1">// nb d'element a generer</span>

  <span class="cm">/*PLacement et creation fenetre*/</span>

  <span class="n">SDL_Window</span> <span class="o">**</span><span class="n">tabWindow</span><span class="p">;</span>
  <span class="n">tabWindow</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Window</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SDL_Window</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">nbr_element</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbr_element</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">tabWindow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span>
        <span class="s">"Fenetre"</span><span class="p">,</span>                  <span class="c1">// codage en utf8, donc accents possibles</span>
        <span class="n">i</span> <span class="o">*</span> <span class="n">TAILLE_FENETRE</span><span class="p">,</span> <span class="n">milieu</span><span class="p">,</span> <span class="c1">// a coté de sa voisine et au milieu de l'ecran en y</span>
        <span class="n">TAILLE_FENETRE</span><span class="p">,</span> <span class="n">TAILLE_FENETRE</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">);</span> <span class="c1">// non redimensionnable</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tabWindow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">SDL_Log</span><span class="p">(</span><span class="s">"Error : SDL window %d creation - %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
              <span class="n">i</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span> <span class="c1">// échec de la création de la fenêtre</span>
      <span class="n">SDL_Quit</span><span class="p">();</span>                 <span class="c1">// On referme la SDL</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/*ANimation 1*/</span>
  <span class="cm">/*on créé la courbe cosinus*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbr_element</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/*cos a chaque point "I * TAILLE_FENETRE*/</span>
    <span class="kt">float</span> <span class="n">val_cos</span> <span class="o">=</span> <span class="n">cosf</span><span class="p">((</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">TAILLE_FENETRE</span><span class="p">);</span>
    <span class="cm">/*cos au carré pour osciller entre 0 et 1 et pas -1 et 1 puis d'amplitude de taille "hauteur ecran / 2 qu'on recentre au milieu avec + milieu /2"*/</span>
    <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">tabWindow</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">*</span> <span class="n">TAILLE_FENETRE</span><span class="p">,</span> <span class="p">(</span><span class="n">val_cos</span> <span class="o">*</span> <span class="n">val_cos</span> <span class="o">*</span> <span class="n">milieu</span><span class="p">)</span> <span class="o">+</span> <span class="n">milieu</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*Animation 2*/</span>
  <span class="cm">/*on fait osciller en changeant la valeur x des points avec une variante*/</span>
  <span class="kt">int</span> <span class="n">variante</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">variante</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbr_element</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">float</span> <span class="n">val_cos</span> <span class="o">=</span> <span class="n">cosf</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">variante</span><span class="p">)</span> <span class="o">*</span> <span class="n">TAILLE_FENETRE</span><span class="p">);</span>
      <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">tabWindow</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">*</span> <span class="n">TAILLE_FENETRE</span><span class="p">,</span> <span class="p">(</span><span class="n">val_cos</span> <span class="o">*</span> <span class="n">val_cos</span> <span class="o">*</span> <span class="n">milieu</span><span class="p">)</span> <span class="o">+</span> <span class="n">milieu</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">variante</span><span class="o">++</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"iteration n°%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">variante</span><span class="p">);</span>
    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*ANimation 3*/</span>
  <span class="cm">/*on replace au milieu*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nbr_element</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">tabWindow</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">*</span> <span class="n">TAILLE_FENETRE</span><span class="p">,</span> <span class="n">milieu</span><span class="p">);</span>
    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*Supression fenetre*/</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbr_element</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">tabWindow</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"clear fenetre %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">free</span><span class="p">(</span><span class="n">tabWindow</span><span class="p">);</span>
</code></pre></div><h3 id='video'>Vidéo</h3>
<p align="center"><iframe width="80%" height="315" src="https://www.youtube.com/embed/PmCJ4XlQqXs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id='leger-bertrand'>LEGER Bertrand</h2><h3 id='explication-et-code-2'>Explication et Code</h3>
<p>Principe :
J&#39;ouvre des fenêtres sur les côtés de l&#39;écran en partant du milieu de la hauteur et du côté gauche et droit puis elles disparaissent. Puis j&#39;ouvre des fenêtres et je les fais &quot;spiraler&quot; grâce au cosinus et
en augmentant le rayon du cercle à chaque itération, je finis par fermer toutes mes fenêtres une à une.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="n">SDL_Window</span> <span class="o">*</span><span class="n">windows</span><span class="p">[</span><span class="n">NBREWINDOWS</span><span class="p">];</span>

  <span class="n">SDL_DisplayMode</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">SDL_GetCurrentDisplayMode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">h</span><span class="p">;</span>

  <span class="kt">float</span> <span class="n">position_x_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// première fenêtre côté gauche au milieu de la largeur de l'écran</span>
  <span class="kt">float</span> <span class="n">position_y_left</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

  <span class="kt">float</span> <span class="n">position_x_right</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span> <span class="c1">// première fenêtre côté droit au milieu de la largeur de l'écran</span>
  <span class="kt">float</span> <span class="n">position_y_right</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

  <span class="cm">/*Animation 1:
   *ligne de fenêtre de la moitié de la largeur de l'écran et de longueur = 1/3 de l'écran
   *Qui se referme une fois que la dernière est placée*/</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">position_x_left</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">position_x_right</span> <span class="o">&gt;</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">{</span>

    <span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span>
        <span class="s">"left"</span><span class="p">,</span>
        <span class="n">position_x_left</span><span class="p">,</span> <span class="n">position_y_left</span><span class="p">,</span>
        <span class="mi">40</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">);</span>

    <span class="n">windows</span><span class="p">[</span><span class="mi">200</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span>
        <span class="s">"right"</span><span class="p">,</span>
        <span class="n">position_x_right</span><span class="p">,</span> <span class="n">position_y_right</span><span class="p">,</span>
        <span class="mi">40</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">SDL_WINDOW_RESIZABLE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">windows</span><span class="p">[</span><span class="mi">200</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">SDL_Log</span><span class="p">(</span><span class="s">"Error : SDL window %d creation - %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
      <span class="n">SDL_Quit</span><span class="p">();</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">position_x_left</span> <span class="o">=</span> <span class="n">position_x_left</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
    <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">position_x_left</span><span class="p">,</span> <span class="n">position_y_left</span><span class="p">);</span>

    <span class="n">position_x_right</span> <span class="o">=</span> <span class="n">position_x_right</span> <span class="o">-</span> <span class="mi">15</span><span class="p">;</span>
    <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">position_x_left</span><span class="p">,</span> <span class="n">position_y_left</span><span class="p">);</span>

    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>

  <span class="cm">/*Animation 2 :
   *Je fais tourner fenêtres grâce aux coordonnées du cercle trigonométrique
   *A chaque itération le rayon du cercle va grandir*/</span>

  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>

        <span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="mi">200</span> <span class="o">+</span> <span class="n">j</span><span class="p">]);</span>
        <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">75</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">windows</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span>
        <span class="s">"left circle"</span><span class="p">,</span>
        <span class="n">position_x_left</span><span class="p">,</span> <span class="n">position_y_left</span><span class="p">,</span>
        <span class="mi">40</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">SDL_Log</span><span class="p">(</span><span class="s">"Error : SDL window %d creation - %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
      <span class="n">SDL_Quit</span><span class="p">();</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">pos_x</span> <span class="o">=</span> <span class="n">cosf</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="mi">25</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">position_x_left</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">pos_y</span> <span class="o">=</span> <span class="n">sinf</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="mi">25</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">position_y_left</span><span class="p">;</span>

    <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">pos_x</span><span class="p">,</span> <span class="n">pos_y</span><span class="p">);</span>

    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">75</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span><span class="o">--</span><span class="p">)</span>
  <span class="p">{</span>

    <span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div><h3 id='video-2'>Vidéo</h3>
<p style="texte-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/j7vuU87j4RA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id='cornuez-charlotte'>CORNUEZ Charlotte</h2><h3 id='explication-et-code-3'>Explication et Code</h3>
<p>Les fenêtres s&#39;affichent petit à petit pour former un U. Puis elles se rassemblent au milieu avant de partir chacune leur tour dans un des coins de l&#39;écran.             </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="cm">/* Récupération de la taille de l'écran */</span>

    <span class="n">SDL_DisplayMode</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">SDL_GetCurrentDisplayMode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">current</span><span class="p">.</span><span class="n">h</span><span class="p">;</span>
    <span class="c1">// printf("%d %d\n", width,height);</span>

    <span class="cm">/* Création des fenêtres */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TabWindows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span>
            <span class="s">"Fenêtres U"</span><span class="p">,</span>              <span class="c1">// codage en utf8, donc accents possibles</span>
            <span class="n">width</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="c1">// coin haut gauche en haut gauche de l'écran</span>
            <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span>                  <span class="c1">// largeur = 400, hauteur = 300</span>
            <span class="n">SDL_WINDOW_RESIZABLE</span><span class="p">);</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>

        <span class="cm">/* Vérification de la création des fenêtres */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SDL_Log</span><span class="p">(</span><span class="s">"Error : SDL window 1 creation - %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">SDL_GetError</span><span class="p">());</span> <span class="c1">// échec de la création de la fenêtre</span>
            <span class="n">SDL_Quit</span><span class="p">();</span>              <span class="c1">// On referme la SDL</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">29</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TabWindows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span>
            <span class="s">"Fenêtres U"</span><span class="p">,</span>                              <span class="c1">// codage en utf8, donc accents possibles</span>
            <span class="n">width</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">14</span><span class="p">)</span> <span class="o">*</span> <span class="mi">25</span><span class="p">,</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="c1">// coin haut gauche en haut gauche de l'écran</span>
            <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span>                                  <span class="c1">// largeur = 400, hauteur = 300</span>
            <span class="n">SDL_WINDOW_RESIZABLE</span><span class="p">);</span>

        <span class="cm">/* Vérification de la création des fenêtres */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SDL_Log</span><span class="p">(</span><span class="s">"Error : SDL window 1 creation - %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">SDL_GetError</span><span class="p">());</span> <span class="c1">// échec de la création de la fenêtre</span>
            <span class="n">SDL_Quit</span><span class="p">();</span>              <span class="c1">// On referme la SDL</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">29</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">44</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TabWindows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span>
            <span class="s">"Fenêtres U"</span><span class="p">,</span>                          <span class="c1">// codage en utf8, donc accents possibles</span>
            <span class="n">width</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="mi">14</span> <span class="o">*</span> <span class="mi">25</span><span class="p">),</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="c1">// coin haut gauche en haut gauche de l'écran</span>
            <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span>                              <span class="c1">// largeur = 400, hauteur = 300</span>
            <span class="n">SDL_WINDOW_RESIZABLE</span><span class="p">);</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>

        <span class="cm">/* Vérification de la création des fenêtres */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SDL_Log</span><span class="p">(</span><span class="s">"Error : SDL window 1 creation - %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">SDL_GetError</span><span class="p">());</span> <span class="c1">// échec de la création de la fenêtre</span>
            <span class="n">SDL_Quit</span><span class="p">();</span>              <span class="c1">// On referme la SDL</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="cm">/*Mise en place d'une étoile : les points vont aux quatres coins*/</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">etoile</span><span class="p">;</span> <span class="n">etoile</span> <span class="o">&lt;</span> <span class="mi">45</span><span class="p">;</span> <span class="n">etoile</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">etoile</span><span class="p">],</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">etoile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">etoile</span> <span class="o">&lt;</span> <span class="mi">44</span><span class="p">;</span> <span class="n">etoile</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">200</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">etoile</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="p">((</span><span class="n">width</span> <span class="o">-</span> <span class="mi">200</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">200</span><span class="p">))</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>

            <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">etoile</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>

            <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">etoile</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">,</span> <span class="p">((</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">width</span><span class="p">);</span>

            <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">SDL_SetWindowPosition</span><span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">etoile</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">,</span> <span class="p">((</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">width</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">((</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">width</span><span class="p">);</span>
            <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

    <span class="cm">/* Fermeture des fenêtres */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">45</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">TabWindows</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

</code></pre></div><h3 id='video-3'>Vidéo</h3>
<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/CKo6G8Bd3j0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h1 id='animation-forme'>Animation Forme</h1><h2 id='ballejos-lilian-2'>BALLEJOS Lilian</h2><h3 id='explication-et-code-4'>Explication et Code</h3>
<p>Mise en place d&#39;un programme qui crée une fenêtre blanche et fait apparaître deux ellipses qui se croisent à intervalles réguliers et forment des ronds.
Pour faire cela, il a suffit de changer le rayon des cercles sur les composantes X et Y en le décalant de 10 de taille. Ensuite on inverse le rayon des composante X et Y entre les deux ellipses afin de les inverser entre elles ! De plus on joue avec les composantes de couleur pour changer la couleur des carrés qui forment les ellipses.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">largeur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hauteur</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*Tableau de rectangle assez petit pour sembler etre des points*/</span>
    <span class="n">SDL_Rect</span> <span class="o">*</span><span class="n">rectangles</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Rect</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SDL_Rect</span><span class="p">)</span> <span class="o">*</span> <span class="n">NBR_RECTANGLE</span><span class="p">);</span>
    <span class="n">SDL_Rect</span> <span class="o">*</span><span class="n">rectangles2</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Rect</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SDL_Rect</span><span class="p">)</span> <span class="o">*</span> <span class="n">NBR_RECTANGLE</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">cercleTailleX</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cercleTailleY</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="cm">/*taille des cercles pas la même pour avoir alternance ellispse et cercle*/</span>
    <span class="kt">int</span> <span class="n">couleurR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">couleurG</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="cm">/*couleur varie*/</span>
    <span class="kt">int</span> <span class="n">couleurB</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">interation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">interation</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                <span class="c1">// fond blanc</span>
        <span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>                                           <span class="c1">// efface le rendu précédent</span>
        <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">couleurR</span><span class="p">,</span> <span class="n">couleurG</span><span class="p">,</span> <span class="n">couleurB</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span> <span class="c1">// couleur rectangle</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBR_RECTANGLE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">float</span> <span class="n">valCos</span> <span class="o">=</span> <span class="n">cosf</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">valSin</span> <span class="o">=</span> <span class="n">sinf</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">cercleTailleX</span> <span class="o">*</span> <span class="n">valCos</span> <span class="o">+</span> <span class="n">largeur</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">cercleTailleY</span> <span class="o">*</span> <span class="n">valSin</span> <span class="o">+</span> <span class="n">hauteur</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">TAILLE_RECT</span><span class="p">;</span>
            <span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">h</span> <span class="o">=</span> <span class="n">TAILLE_RECT</span><span class="p">;</span>
            <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// on applique le rectangle</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBR_RECTANGLE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">float</span> <span class="n">valCos</span> <span class="o">=</span> <span class="n">cosf</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">valSin</span> <span class="o">=</span> <span class="n">sinf</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="cm">/*on inverse les largeur x et y avec le premier pour avoir une belle forme*/</span>
            <span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">cercleTailleY</span> <span class="o">*</span> <span class="n">valCos</span> <span class="o">+</span> <span class="n">largeur</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">cercleTailleX</span> <span class="o">*</span> <span class="n">valSin</span> <span class="o">+</span> <span class="n">hauteur</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">TAILLE_RECT</span><span class="p">;</span>
            <span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">h</span> <span class="o">=</span> <span class="n">TAILLE_RECT</span><span class="p">;</span>
            <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// on applique le rectangle</span>
        <span class="p">}</span>

        <span class="n">cercleTailleX</span> <span class="o">=</span> <span class="p">(</span><span class="n">cercleTailleX</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">%</span> <span class="mi">300</span><span class="p">;</span>
        <span class="n">cercleTailleY</span> <span class="o">=</span> <span class="p">(</span><span class="n">cercleTailleY</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">%</span> <span class="mi">400</span><span class="p">;</span>
        <span class="n">couleurR</span> <span class="o">=</span> <span class="p">(</span><span class="n">couleurR</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">200</span><span class="p">;</span>
        <span class="n">couleurG</span> <span class="o">=</span> <span class="p">(</span><span class="n">couleurG</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">200</span><span class="p">;</span> <span class="c1">// modulo 200 pour eviter le blanc en 255</span>
        <span class="n">couleurB</span> <span class="o">=</span> <span class="p">(</span><span class="n">couleurB</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">%</span> <span class="mi">200</span><span class="p">;</span>
        <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span> <span class="c1">// on charge le rendu</span>
        <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">75</span><span class="p">);</span>
        <span class="n">interation</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">free</span><span class="p">(</span><span class="n">rectangles</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">rectangles2</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div><h3 id='video-4'>Vidéo</h3>
<p align="center"><iframe width="80%" height="315" src="https://www.youtube.com/embed/9enCd_bTOAw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id='cornuez-charlotte-2'>CORNUEZ Charlotte</h2><h3 id='explication-et-code-5'>Explication et Code</h3>
<p>Le but de ce programme est de créer un cube qui tombe sur une pente.<br>
Pour cela, on crée d&#39;abord un rectangle de taille 1920*1080 dans lequel on crée une pente à l&#39;aide d&#39;une droite.
Un cube orange descend petit à petit la pente pour arriver sur le plat.                 </p>
<div class="highlight"><pre class="highlight c tab-c"><code>
<span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">renderer</span><span class="p">)</span> <span class="p">{</span>                                 <span class="c1">// Je pense que vous allez faire moins laid :)</span>
  <span class="n">SDL_Rect</span> <span class="n">rectangle</span><span class="p">,</span><span class="n">cube</span><span class="p">;</span>                                                             

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                                
                         <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>                                  <span class="c1">// mode Red, Green, Blue (tous dans 0..255)</span>
                         <span class="mi">255</span><span class="p">);</span>                                      <span class="c1">// 0 = transparent ; 255 = opaque</span>
  <span class="n">rectangle</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// x haut gauche du rectangle</span>
  <span class="n">rectangle</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// y haut gauche du rectangle</span>
  <span class="n">rectangle</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">;</span>                                                <span class="c1">// sa largeur (w = width)</span>
  <span class="n">rectangle</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1080</span><span class="p">;</span>                                                <span class="c1">// sa hauteur (h = height)</span>

  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangle</span><span class="p">);</span>                         



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                   
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                      
                     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                          <span class="c1">// x,y du point de la première extrémité</span>
                     <span class="mi">600</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>                                     <span class="c1">// x,y seconde extrémité</span>

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>
                      <span class="mi">600</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span>
                      <span class="mi">1920</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">58</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">cube</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>
  <span class="n">cube</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">37</span><span class="p">;</span>
  <span class="n">cube</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">cube</span><span class="p">.</span><span class="n">h</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cube</span><span class="p">);</span>

  <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>


  <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

  <span class="n">SDL_Rect</span> <span class="n">rectangle1</span><span class="p">,</span><span class="n">cube1</span><span class="p">;</span>                                                             

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                                
                         <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>                                  <span class="c1">// mode Red, Green, Blue (tous dans 0..255)</span>
                         <span class="mi">255</span><span class="p">);</span>                                      <span class="c1">// 0 = transparent ; 255 = opaque</span>
  <span class="n">rectangle1</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// x haut gauche du rectangle</span>
  <span class="n">rectangle1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// y haut gauche du rectangle</span>
  <span class="n">rectangle1</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">;</span>                                                <span class="c1">// sa largeur (w = width)</span>
  <span class="n">rectangle1</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1080</span><span class="p">;</span>                                                <span class="c1">// sa hauteur (h = height)</span>

  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangle1</span><span class="p">);</span>                         



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                   
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                      
                     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                          <span class="c1">// x,y du point de la première extrémité</span>
                     <span class="mi">600</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>                                     <span class="c1">// x,y seconde extrémité</span>

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>
                      <span class="mi">600</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span>
                      <span class="mi">1920</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">58</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">cube1</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="mi">200</span><span class="p">;</span>
  <span class="n">cube1</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">115</span><span class="p">;</span>
  <span class="n">cube1</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">cube1</span><span class="p">.</span><span class="n">h</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cube1</span><span class="p">);</span>
  <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>


  <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

  <span class="n">SDL_Rect</span> <span class="n">rectangle2</span><span class="p">,</span><span class="n">cube2</span><span class="p">;</span>                                                             

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                                
                         <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>                                  <span class="c1">// mode Red, Green, Blue (tous dans 0..255)</span>
                         <span class="mi">255</span><span class="p">);</span>                                      <span class="c1">// 0 = transparent ; 255 = opaque</span>
  <span class="n">rectangle2</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// x haut gauche du rectangle</span>
  <span class="n">rectangle2</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// y haut gauche du rectangle</span>
  <span class="n">rectangle2</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">;</span>                                                <span class="c1">// sa largeur (w = width)</span>
  <span class="n">rectangle2</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1080</span><span class="p">;</span>                                                <span class="c1">// sa hauteur (h = height)</span>

  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangle2</span><span class="p">);</span>                         



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                   
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                      
                     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                          <span class="c1">// x,y du point de la première extrémité</span>
                     <span class="mi">600</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>                                     <span class="c1">// x,y seconde extrémité</span>

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>
                      <span class="mi">600</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span>
                      <span class="mi">1920</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">58</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">cube2</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="mi">300</span><span class="p">;</span>
  <span class="n">cube2</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">197</span><span class="p">;</span>
  <span class="n">cube2</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">cube2</span><span class="p">.</span><span class="n">h</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cube2</span><span class="p">);</span>

  <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>


  <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

  <span class="n">SDL_Rect</span> <span class="n">rectangle3</span><span class="p">,</span><span class="n">cube3</span><span class="p">;</span>                                                             

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                                
                         <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>                                  <span class="c1">// mode Red, Green, Blue (tous dans 0..255)</span>
                         <span class="mi">255</span><span class="p">);</span>                                      <span class="c1">// 0 = transparent ; 255 = opaque</span>
  <span class="n">rectangle3</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// x haut gauche du rectangle</span>
  <span class="n">rectangle3</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// y haut gauche du rectangle</span>
  <span class="n">rectangle3</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">;</span>                                                <span class="c1">// sa largeur (w = width)</span>
  <span class="n">rectangle3</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1080</span><span class="p">;</span>                                                <span class="c1">// sa hauteur (h = height)</span>

  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangle3</span><span class="p">);</span>                         



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                   
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                      
                     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                          <span class="c1">// x,y du point de la première extrémité</span>
                     <span class="mi">600</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>                                     <span class="c1">// x,y seconde extrémité</span>

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>
                      <span class="mi">600</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span>
                      <span class="mi">1920</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">58</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">cube3</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="mi">400</span><span class="p">;</span>
  <span class="n">cube3</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">280</span><span class="p">;</span>
  <span class="n">cube3</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">cube3</span><span class="p">.</span><span class="n">h</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cube3</span><span class="p">);</span>

  <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>


  <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

  <span class="n">SDL_Rect</span> <span class="n">rectangle4</span><span class="p">,</span><span class="n">cube4</span><span class="p">;</span>                                                             

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                                
                         <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>                                  <span class="c1">// mode Red, Green, Blue (tous dans 0..255)</span>
                         <span class="mi">255</span><span class="p">);</span>                                      <span class="c1">// 0 = transparent ; 255 = opaque</span>
  <span class="n">rectangle4</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// x haut gauche du rectangle</span>
  <span class="n">rectangle4</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// y haut gauche du rectangle</span>
  <span class="n">rectangle4</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">;</span>                                                <span class="c1">// sa largeur (w = width)</span>
  <span class="n">rectangle4</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1080</span><span class="p">;</span>                                                <span class="c1">// sa hauteur (h = height)</span>

  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangle4</span><span class="p">);</span>                         



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                   
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                      
                     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                          <span class="c1">// x,y du point de la première extrémité</span>
                     <span class="mi">600</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>                                     <span class="c1">// x,y seconde extrémité</span>

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>
                      <span class="mi">600</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span>
                      <span class="mi">1920</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">58</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">cube4</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="mi">500</span><span class="p">;</span>
  <span class="n">cube4</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">365</span><span class="p">;</span>
  <span class="n">cube4</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">cube4</span><span class="p">.</span><span class="n">h</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cube4</span><span class="p">);</span>

<span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>


  <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

  <span class="n">SDL_Rect</span> <span class="n">rectangle5</span><span class="p">,</span><span class="n">cube5</span><span class="p">;</span>                                                             

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                                
                         <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>                                  <span class="c1">// mode Red, Green, Blue (tous dans 0..255)</span>
                         <span class="mi">255</span><span class="p">);</span>                                      <span class="c1">// 0 = transparent ; 255 = opaque</span>
  <span class="n">rectangle5</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// x haut gauche du rectangle</span>
  <span class="n">rectangle5</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// y haut gauche du rectangle</span>
  <span class="n">rectangle5</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">;</span>                                                <span class="c1">// sa largeur (w = width)</span>
  <span class="n">rectangle5</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1080</span><span class="p">;</span>                                                <span class="c1">// sa hauteur (h = height)</span>

  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangle5</span><span class="p">);</span>                         



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                   
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                      
                     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                          <span class="c1">// x,y du point de la première extrémité</span>
                     <span class="mi">600</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>                                     <span class="c1">// x,y seconde extrémité</span>

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>
                      <span class="mi">600</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span>
                      <span class="mi">1920</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">58</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">cube5</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="mi">600</span><span class="p">;</span>
  <span class="n">cube5</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">450</span><span class="p">;</span>
  <span class="n">cube5</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">cube5</span><span class="p">.</span><span class="n">h</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cube5</span><span class="p">);</span>

  <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>


  <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

  <span class="n">SDL_Rect</span> <span class="n">rectangle6</span><span class="p">,</span><span class="n">cube6</span><span class="p">;</span>                                                             

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                                
                         <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>                                  <span class="c1">// mode Red, Green, Blue (tous dans 0..255)</span>
                         <span class="mi">255</span><span class="p">);</span>                                      <span class="c1">// 0 = transparent ; 255 = opaque</span>
  <span class="n">rectangle6</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// x haut gauche du rectangle</span>
  <span class="n">rectangle6</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// y haut gauche du rectangle</span>
  <span class="n">rectangle6</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">;</span>                                                <span class="c1">// sa largeur (w = width)</span>
  <span class="n">rectangle6</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1080</span><span class="p">;</span>                                                <span class="c1">// sa hauteur (h = height)</span>

  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangle6</span><span class="p">);</span>                         



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                   
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                      
                     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                          <span class="c1">// x,y du point de la première extrémité</span>
                     <span class="mi">600</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>                                     <span class="c1">// x,y seconde extrémité</span>

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>
                      <span class="mi">600</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span>
                      <span class="mi">1920</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>



  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">58</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
  <span class="n">cube6</span><span class="p">.</span><span class="n">x</span><span class="o">=</span><span class="mi">700</span><span class="p">;</span>
  <span class="n">cube6</span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">450</span><span class="p">;</span>
  <span class="n">cube6</span><span class="p">.</span><span class="n">w</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">cube6</span><span class="p">.</span><span class="n">h</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>
  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cube6</span><span class="p">);</span>


<span class="p">}</span>
</code></pre></div><h3 id='video-5'>Vidéo</h3>
<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/0oiR6EIlI3Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id='leger-bertrand-2'>LEGER Bertrand</h2><h3 id='explication-et-code-6'>Explication et Code</h3>
<p>Principe
Faire afficher une fenêtre, mettre le fond de la fenêtre en bleu fonçé 
Faire apparaître des lignes, représentant la pluie, qui apparaissent aléatoirement
Rajouter des cercles au point d&#39;impact pour faire un effet d&#39;eau touchant de l&#39;eau</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">void</span> <span class="nf">drawCircle</span><span class="p">(</span><span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">renderer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">centre_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">centre_y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rayon_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rayon_y</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span> <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">M_PI</span><span class="p">;</span> <span class="n">angle</span> <span class="o">+=</span> <span class="n">M_PI</span> <span class="o">/</span> <span class="mi">4000</span><span class="p">){</span>
    <span class="n">SDL_RenderDrawPoint</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>
            <span class="n">centre_x</span> <span class="o">+</span> <span class="n">rayon_x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>
            <span class="n">centre_y</span> <span class="o">+</span> <span class="n">rayon_y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">));</span>
  <span class="p">}</span>  
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">renderer</span><span class="p">)</span> <span class="p">{</span>                                
  <span class="n">SDL_Rect</span> <span class="n">rectangle</span><span class="p">;</span>                                                             

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                                
                         <span class="mi">37</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">133</span><span class="p">,</span>                               <span class="c1">// mode Red, Green, Blue (tous dans 0..255)</span>
                         <span class="mi">255</span><span class="p">);</span>                                      <span class="c1">// 0 = transparent ; 255 = opaque</span>
  <span class="n">rectangle</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// x haut gauche du rectangle</span>
  <span class="n">rectangle</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                                  <span class="c1">// y haut gauche du rectangle</span>
  <span class="n">rectangle</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>                                                <span class="c1">// sa largeur (w = width)</span>
  <span class="n">rectangle</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>                                                <span class="c1">// sa hauteur (h = height)</span>

  <span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rectangle</span><span class="p">);</span>                         

  <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">222</span><span class="p">,</span> <span class="mi">238</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>                   


  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">pos_x_deb</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span> <span class="mi">600</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pos_y_deb</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span> <span class="mi">600</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pos_x_fin</span> <span class="o">=</span> <span class="n">pos_x_deb</span> <span class="o">-</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">50</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pos_y_fin</span> <span class="o">=</span> <span class="n">pos_y_deb</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">600</span> <span class="p">;</span>


    <span class="n">SDL_RenderDrawLine</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span>                                      
               <span class="n">pos_x_deb</span><span class="p">,</span> <span class="n">pos_y_deb</span><span class="p">,</span>                                      <span class="c1">// x,y du point de la première extrémité</span>
               <span class="n">pos_x_fin</span><span class="p">,</span> <span class="n">pos_y_fin</span><span class="p">);</span>                                     <span class="c1">// x,y seconde extrémité</span>

  <span class="n">drawCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="n">pos_x_fin</span><span class="p">,</span><span class="n">pos_y_fin</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">23</span><span class="p">);</span>
  <span class="n">drawCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="n">pos_x_fin</span><span class="p">,</span><span class="n">pos_y_fin</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">17</span><span class="p">);</span>
  <span class="n">drawCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span><span class="n">pos_x_fin</span><span class="p">,</span><span class="n">pos_y_fin</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></div><h3 id='video-6'>Vidéo</h3>
<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/3bOyuSg8Ctk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h1 id='animation-avec-texture'>Animation avec Texture</h1><h2 id='ballejos-lilian-3'>BALLEJOS Lilian</h2><h3 id='explication-et-code-7'>Explication et Code</h3>
<p>Placement d&#39;une image de fond de nuage en mouvement qui va de gauche à droite et se replace à gauche quand elle va déborder !
J&#39;ai ensuite posé une texture de sol <strong>très</strong> inspirée de l&#39;univers d&#39;un plombier italien rouge.
Ensuite j&#39;affiche frame par frame un oiseau qui traverse l&#39;écran de gauche à droite !</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="c1">// placement fond</span>
<span class="kt">void</span> <span class="nf">placementTexture</span><span class="p">(</span><span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">my_texture</span><span class="p">,</span> <span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">,</span>
                      <span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SDL_Rect</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
        <span class="n">window_dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>
        <span class="n">destination</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">SDL_GetWindowSize</span><span class="p">(</span>
        <span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de la fenêtre</span>
    <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">my_texture</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                     <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de l'image</span>

    <span class="n">destination</span> <span class="o">=</span> <span class="n">window_dimensions</span><span class="p">;</span> <span class="c1">// On fixe les dimensions de l'affichage à  celles de la fenêtre</span>

    <span class="cm">/* On veut afficher la texture de façon à ce que l'image occupe la totalité de la fenêtre */</span>

    <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">my_texture</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">destination</span><span class="p">);</span> <span class="c1">// Création de l'élément à afficher</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">anim</span><span class="p">(</span><span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">ciel</span><span class="p">,</span>
          <span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">,</span>
          <span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span>
          <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">sol</span><span class="p">,</span>
          <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">oiseau</span><span class="p">)</span>
<span class="p">{</span>

    <span class="cm">/* perso*/</span>
    <span class="n">SDL_Rect</span>
        <span class="n">source2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>            <span class="c1">// Rectangle définissant la zone totale de la planche</span>
        <span class="n">window_dimensions2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="c1">// Rectangle définissant la fenêtre, on n'utilisera que largeur et hauteur</span>
        <span class="n">destination2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>       <span class="c1">// Rectangle définissant où la zone_source doit être déposée dans le renderer</span>
        <span class="n">state2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>             <span class="c1">// Rectangle de la vignette en cours dans la planche</span>

    <span class="n">SDL_GetWindowSize</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="c1">// Récupération des dimensions de la fenêtre</span>
                      <span class="o">&amp;</span><span class="n">window_dimensions2</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
                      <span class="o">&amp;</span><span class="n">window_dimensions2</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>

    <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">oiseau</span><span class="p">,</span> <span class="c1">// Récupération des dimensions de l'image</span>
                     <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                     <span class="o">&amp;</span><span class="n">source2</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source2</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"dim image %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">source2</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">source2</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">nb_images</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset_x</span> <span class="o">=</span> <span class="n">source2</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="n">nb_images</span><span class="p">,</span> <span class="c1">// 5 frame par ligne</span>
        <span class="n">offset_y</span> <span class="o">=</span> <span class="n">source2</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>         <span class="c1">// 3 lignes</span>

    <span class="n">state2</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">state2</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// premiere ligne</span>
    <span class="n">state2</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">offset_x</span><span class="p">;</span>
    <span class="n">state2</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">offset_y</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"offeset %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">offset_x</span><span class="p">,</span> <span class="n">offset_y</span><span class="p">);</span>

    <span class="n">destination2</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">offset_x</span><span class="p">;</span>
    <span class="n">destination2</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">offset_y</span><span class="p">;</span>
    <span class="n">destination2</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">window_dimensions2</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">destination2</span><span class="p">.</span><span class="n">h</span><span class="p">;</span> <span class="c1">// La course se fait en milieu d'écran (en vertical)</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"destination H et W %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">destination2</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">destination2</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>

    <span class="cm">/* fond */</span>
    <span class="n">SDL_Rect</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>            <span class="c1">// Rectangle définissant la zone de la texture à récupérer</span>
        <span class="n">window_dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="c1">// Rectangle définissant la fenêtre, on n'utilisera que largeur et hauteur</span>
        <span class="n">destination</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>       <span class="c1">// Rectangle définissant où la zone_source doit être déposée dans le renderer</span>

    <span class="n">SDL_GetWindowSize</span><span class="p">(</span>
        <span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de la fenêtre</span>

    <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">ciel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                     <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
                     <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de l'image</span>

    <span class="kt">float</span> <span class="n">zoom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>                <span class="c1">// Facteur de zoom entre l'image source et l'image affichée pour fond</span>
    <span class="n">destination</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">zoom</span><span class="p">;</span> <span class="c1">// On applique le zoom sur la largeur</span>
    <span class="n">destination</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">h</span> <span class="o">*</span> <span class="n">zoom</span><span class="p">;</span> <span class="c1">// On applique le zoom sur la hauteur</span>
    <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">source</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1">// au depart a droite</span>

    <span class="kt">int</span> <span class="n">speed</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// vitesse de déplacement</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// depart oiseau</span>
    <span class="n">SDL_bool</span> <span class="n">program_on</span> <span class="o">=</span> <span class="n">SDL_TRUE</span><span class="p">;</span>
    <span class="n">SDL_Event</span> <span class="n">event</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">program_on</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
            <span class="p">{</span>
            <span class="k">case</span> <span class="n">SDL_QUIT</span><span class="p">:</span>
                <span class="n">program_on</span> <span class="o">=</span> <span class="n">SDL_FALSE</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/*animation*/</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">speed</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// on atteind le bout de l'image le fond retourne a sa place</span>
        <span class="p">{</span>
            <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">source</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">destination2</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">state2</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">offset_x</span><span class="p">;</span>  <span class="c1">// On passe à la vignette suivante dans l'image</span>
        <span class="n">state2</span><span class="p">.</span><span class="n">x</span> <span class="o">%=</span> <span class="n">source2</span><span class="p">.</span><span class="n">w</span><span class="p">;</span> <span class="c1">// On réinitialise à 0 si on dépasse la largeur</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"etat %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">state2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">state2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"destination %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">destination2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">destination2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

        <span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>                                <span class="c1">// Effacer l'image précédente</span>
        <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">ciel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">destination</span><span class="p">);</span>    <span class="c1">// Préparation de l'affichage</span>
        <span class="n">placementTexture</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">renderer</span><span class="p">);</span>                  <span class="c1">// Afficher le sol</span>
        <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">oiseau</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">destination2</span><span class="p">);</span> <span class="c1">// personnage</span>
        <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>                              <span class="c1">// Affichage de la nouvelle image</span>
        <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="p">)</span>
            <span class="n">program_on</span> <span class="o">=</span> <span class="o">!</span><span class="n">program_on</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id='video-7'>Vidéo</h3>
<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/XjAD57nNzGw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id='leger-bertrand-3'>LEGER Bertrand</h2><h3 id='explication-et-code-8'>Explication et Code</h3>
<p>Principe  : afficher le ciel en fond, le panier à droite et faire arriver le ballon de basket (en le faisant tourner) dans le panier avec un arc parabolique typique d&#39;un tir de basketball.</p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="kt">void</span> <span class="nf">AffichageObjet</span><span class="p">(</span><span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span> <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">objet</span><span class="p">,</span> <span class="n">SDL_Rect</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SDL_Rect</span> <span class="n">image</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">objet</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
  <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">objet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>

<span class="p">}</span>



<span class="kt">void</span> <span class="nf">Animation</span><span class="p">(</span><span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">,</span>
           <span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span>
           <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">panier</span><span class="p">,</span>
           <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">ciel</span><span class="p">,</span>
           <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">ballon</span><span class="p">)</span>
<span class="p">{</span>


  <span class="cm">/* fond */</span>
  <span class="n">SDL_Rect</span>
    <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>            <span class="c1">// Rectangle définissant la zone de la texture à récupérer</span>
    <span class="n">window_dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="c1">// Rectangle définissant la fenêtre, on n'utilisera que largeur et hauteur</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>       <span class="c1">// Rectangle définissant où la zone_source doit être déposée dans le renderer</span>
    <span class="n">posPanier</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>


  <span class="n">SDL_GetWindowSize</span><span class="p">(</span>
            <span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de la fenêtre</span>

  <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">ciel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
           <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
           <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de l'image</span>

  <span class="kt">float</span> <span class="n">zoom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>                <span class="c1">// Facteur de zoom entre l'image source et l'image affichée pour fond</span>
  <span class="n">destination</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">zoom</span><span class="p">;</span> <span class="c1">// On applique le zoom sur la largeur</span>
  <span class="n">destination</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">h</span> <span class="o">*</span> <span class="n">zoom</span><span class="p">;</span> <span class="c1">// On applique le zoom sur la hauteur</span>
  <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">source</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1">// au depart a droite</span>

  <span class="cm">/* position Panier */</span>

  <span class="n">posPanier</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
  <span class="n">posPanier</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
  <span class="n">posPanier</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">60</span><span class="o">*</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span>
  <span class="n">posPanier</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span> <span class="o">-</span> <span class="n">posPanier</span><span class="p">.</span><span class="n">h</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span> <span class="cm">/*+100 car la hauteur du png fais plus
                               que la hauteur du panier en soit*/</span>


  <span class="cm">/* ballon */</span>

  <span class="c1">//découpage du sprite et on les met tous dans un tableau de SDL_Rect pour pouvoir les utilsez dans l'animation</span>

  <span class="c1">//int a, b, c ;</span>


  <span class="n">SDL_Rect</span>
    <span class="n">planche</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>    <span class="c1">//rectangle de toute la table de sprite</span>
    <span class="n">posBallon</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>        <span class="c1">//rectangle à chaque itération du sprite</span>

  <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">ballon</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">planche</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">planche</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">offsetX</span> <span class="o">=</span> <span class="n">planche</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">offsetY</span> <span class="o">=</span> <span class="n">planche</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">//3 lignes et 4 colonnes</span>

  <span class="n">SDL_Rect</span> <span class="n">etats</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

  <span class="kt">int</span> <span class="n">indice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
      <span class="n">etats</span><span class="p">[</span><span class="n">indice</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">offsetX</span><span class="p">;</span>
      <span class="n">etats</span><span class="p">[</span><span class="n">indice</span><span class="p">].</span><span class="n">h</span> <span class="o">=</span> <span class="n">offsetY</span><span class="p">;</span>
      <span class="n">etats</span><span class="p">[</span><span class="n">indice</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">offsetX</span><span class="p">;</span>
      <span class="n">etats</span><span class="p">[</span><span class="n">indice</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">offsetY</span><span class="p">;</span>
      <span class="n">indice</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

  <span class="c1">//position et dimension du ballon</span>
  <span class="cm">/*posBallon.y = window_dimensions.h -25;
    posBallon.x = 0;
    posBallon.h = 100;
    posBallon.w = 100;*/</span>

  <span class="n">posBallon</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">posBallon</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span><span class="mi">25</span><span class="p">;</span>
  <span class="n">posBallon</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">posBallon</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="c1">// boucle évènement SDL</span>

  <span class="n">SDL_bool</span> <span class="n">program_on</span> <span class="o">=</span> <span class="n">SDL_TRUE</span><span class="p">;</span>
  <span class="n">SDL_Event</span> <span class="n">event</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">program_on</span><span class="p">)</span>
    <span class="p">{</span>

      <span class="k">while</span> <span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">))</span>
        <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
            <span class="p">{</span>
            <span class="k">case</span> <span class="n">SDL_QUIT</span><span class="p">:</span>
          <span class="n">program_on</span> <span class="o">=</span> <span class="n">SDL_FALSE</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>

            <span class="nl">default:</span>
          <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>


      <span class="cm">/*animation*/</span>


      <span class="c1">// c = window_dimensions.h -25 ;</span>

      <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span><span class="p">(</span><span class="n">m</span>  <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">12</span> <span class="p">;</span> <span class="n">m</span> <span class="o">++</span><span class="p">){</span>


    <span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>                                <span class="c1">// Effacer l'image précédente</span>

    <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">ciel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">destination</span><span class="p">);</span>    <span class="c1">// Préparation de l'affichage</span>

    <span class="n">posBallon</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">posBallon</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="mi">60</span><span class="o">*</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">50</span> <span class="p">;</span>

    <span class="cm">/*
     *paramètres de la parabole
     */</span>

    <span class="cm">/*b = ((window_dimensions.h/2)-window_dimensions.h +25 -
      800*(36/100)*window_dimensions.w*window_dimensions.w - 800*156*window_dimensions.w - 800*16900 +
      8*(36/100)*window_dimensions.h*window_dimensions.w*window_dimensions.w
      +8*156*window_dimensions.h*window_dimensions.w + 8*16900*window_dimensions.h -
      100*(36/100)*window_dimensions.w*window_dimensions.w -100*156*window_dimensions.w
      -100*169000)/(-4*((6/10) * (6/10))*window_dimensions.w)/2 - 312 -
      (4*19000)/(window_dimensions.w*2)+(6/10)*window_dimensions.w +130;

      a = 4 * (100 - (b * window_dimensions.w / 2 ) - window_dimensions.h
      +25)/(window_dimensions.w * window_dimensions.w);*/</span>


    <span class="cm">/*équation de la parabole*/</span>

    <span class="cm">/*posBallon.y = -(posBallon.x * posBallon.x) * a + posBallon.x * b + c; */</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">posBallon</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">60</span><span class="o">*</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span> <span class="o">+</span> <span class="mi">130</span> <span class="p">){</span>

      <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">ballon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">etats</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">posBallon</span><span class="p">);</span>        <span class="c1">//ballon</span>

    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>

      <span class="n">program_on</span> <span class="o">=</span> <span class="n">SDL_FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">AffichageObjet</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">panier</span><span class="p">,</span> <span class="n">posPanier</span><span class="p">);</span>              <span class="c1">// Affichage du panier</span>

    <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>                              <span class="c1">// Affichage de la nouvelle image</span>

    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>


      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id='video-8'>Vidéo</h3>
<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/brtEs2HayHE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id='cornuez-charlotte-3'>CORNUEZ Charlotte</h2><h3 id='explication-et-code-9'>Explication et Code</h3>
<p>Affichage d&#39;un jardin puis d&#39;un nuage et enfin d&#39;un dinosaure qui court.
J&#39;affiche en fond un jardin avec un nuage qui traverse le haut du jardin. 
En bas du nuage, on peut voir un dinosaure bleu qui traverse en courant. </p>
<div class="highlight"><pre class="highlight c tab-c"><code><span class="n">SDL_Texture</span> <span class="o">*</span><span class="nf">ImageEnTexture</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">file_image_name</span><span class="p">,</span> <span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">,</span> <span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SDL_Surface</span> <span class="o">*</span><span class="n">my_image</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// Variable de passage</span>
  <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">my_texture</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// La texture</span>

  <span class="n">my_image</span> <span class="o">=</span> <span class="n">IMG_Load</span><span class="p">(</span><span class="n">file_image_name</span><span class="p">);</span> <span class="c1">// Chargement de l'image dans la surface</span>
                                        <span class="c1">// image=SDL_LoadBMP(file_image_name); fonction standard de la SDL,</span>
                                        <span class="c1">// uniquement possible si l'image est au format bmp */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_image</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">end_sdl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"Chargement de l'image impossible"</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">renderer</span><span class="p">);</span>

  <span class="n">my_texture</span> <span class="o">=</span> <span class="n">SDL_CreateTextureFromSurface</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">my_image</span><span class="p">);</span> <span class="c1">// Chargement de l'image de la surface vers la texture</span>
  <span class="n">SDL_FreeSurface</span><span class="p">(</span><span class="n">my_image</span><span class="p">);</span>                                     <span class="c1">// la SDL_Surface ne sert que comme élément transitoire</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_texture</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">end_sdl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"Echec de la transformation de la surface en texture"</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">renderer</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">my_texture</span><span class="p">;</span>
<span class="p">}</span>



<span class="kt">void</span> <span class="nf">AffichageTextureFenetreComplete</span><span class="p">(</span><span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">my_texture</span><span class="p">,</span> <span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">,</span>
                                     <span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SDL_Rect</span>
      <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>            <span class="c1">// Rectangle définissant la zone de la texture à récupérer</span>
      <span class="n">window_dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="c1">// Rectangle définissant la fenêtre, on n'utilisera que largeur et hauteur</span>
      <span class="n">destination</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>       <span class="c1">// Rectangle définissant où la zone_source doit être déposée dans le renderer</span>

  <span class="n">SDL_GetWindowSize</span><span class="p">(</span>
      <span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de la fenêtre</span>
  <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">my_texture</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de l'image</span>

  <span class="n">destination</span> <span class="o">=</span> <span class="n">window_dimensions</span><span class="p">;</span> <span class="c1">// On fixe les dimensions de l'affichage à  celles de la fenêtre</span>

  <span class="cm">/* On veut afficher la texture de façon à ce que l'image occupe la totalité de la fenêtre */</span>

  <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">my_texture</span><span class="p">,</span>
                 <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span>
                 <span class="o">&amp;</span><span class="n">destination</span><span class="p">);</span> <span class="c1">// Création de l'élément à afficher</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">AnimationImage</span><span class="p">(</span><span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">my_texture</span><span class="p">,</span>
                    <span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">,</span>
                    <span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SDL_Rect</span>
      <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>            <span class="c1">// Rectangle définissant la zone de la texture à récupérer</span>
      <span class="n">window_dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="c1">// Rectangle définissant la fenêtre, on n'utilisera que largeur et hauteur</span>
      <span class="n">destination</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>       <span class="c1">// Rectangle définissant où la zone_source doit être déposée dans le renderer</span>

  <span class="n">SDL_GetWindowSize</span><span class="p">(</span>
      <span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de la fenêtre</span>
  <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">my_texture</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// Récupération des dimensions de l'image</span>

  <span class="cm">/* On décide de déplacer dans la fenêtre         cette image */</span>
  <span class="kt">float</span> <span class="n">zoom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="p">;</span> <span class="c1">// Facteur de zoom entre l'image source et l'image affichée</span>

  <span class="n">destination</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">zoom</span><span class="p">;</span> <span class="c1">// On applique le zoom sur la largeur</span>
  <span class="n">destination</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">h</span> <span class="o">*</span> <span class="n">zoom</span><span class="p">;</span> <span class="c1">// On applique le zoom sur la hauteur</span>
  <span class="n">destination</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span>
      <span class="p">(</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span> <span class="o">-</span> <span class="n">destination</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span><span class="p">;</span>   <span class="c1">// On centre en haut</span>
  <span class="kt">float</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span> <span class="o">-</span> <span class="n">destination</span><span class="p">.</span><span class="n">h</span><span class="p">);</span> <span class="c1">// largeur du déplacement à effectuer</span>

  <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mo">005</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// hauteur en fonction du numéro d'image</span>

  <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">my_texture</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">destination</span><span class="p">);</span> <span class="c1">// Préparation de l'affichage</span>
                                                               <span class="c1">// Pause en ms</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">AnimationSprite</span><span class="p">(</span><span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">my_texture</span><span class="p">,</span>
                     <span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">,</span>
                     <span class="n">SDL_Renderer</span> <span class="o">*</span><span class="n">renderer</span><span class="p">,</span>
                     <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">nuage</span><span class="p">,</span>
                     <span class="n">SDL_Texture</span> <span class="o">*</span><span class="n">fond</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SDL_Rect</span>
      <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>            <span class="c1">// Rectangle définissant la zone totale de la planche</span>
      <span class="n">window_dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="c1">// Rectangle définissant la fenêtre, on n'utilisera que largeur et hauteur</span>
      <span class="n">destination</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span>       <span class="c1">// Rectangle définissant où la zone_source doit être déposée dans le renderer</span>
      <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>             <span class="c1">// Rectangle de la vignette en cours dans la planche</span>

  <span class="n">SDL_GetWindowSize</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="c1">// Récupération des dimensions de la fenêtre</span>
                    <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">w</span><span class="p">,</span>
                    <span class="o">&amp;</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>
  <span class="n">SDL_QueryTexture</span><span class="p">(</span><span class="n">my_texture</span><span class="p">,</span> <span class="c1">// Récupération des dimensions de l'image</span>
                   <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">.</span><span class="n">h</span><span class="p">);</span>

  <span class="cm">/* Mais pourquoi prendre la totalité de l'image, on peut n'en afficher qu'un morceau, et changer de morceau :-) */</span>

  <span class="kt">int</span> <span class="n">nb_images</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>                   <span class="c1">// Il y a 8 vignette dans la ligne de l'image qui nous intéresse</span>
  <span class="kt">float</span> <span class="n">zoom</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>                      <span class="c1">// zoom, car ces images sont un peu petites</span>
  <span class="kt">int</span> <span class="n">offset_x</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="n">nb_images</span><span class="p">,</span> <span class="c1">// La largeur d'une vignette de l'image, marche car la planche est bien réglée</span>
      <span class="n">offset_y</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>     <span class="c1">// La hauteur d'une vignette de l'image, marche car la planche est bien réglée</span>

  <span class="n">state</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>            <span class="c1">// La première vignette est en début de ligne</span>
  <span class="n">state</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">offset_y</span><span class="p">;</span> <span class="c1">// On s'intéresse à la 4ème ligne, le bonhomme qui court</span>
  <span class="n">state</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">offset_x</span><span class="p">;</span>     <span class="c1">// Largeur de la vignette</span>
  <span class="n">state</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">offset_y</span><span class="p">;</span>     <span class="c1">// Hauteur de la vignette</span>

  <span class="n">destination</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">offset_x</span> <span class="o">*</span> <span class="n">zoom</span><span class="p">;</span> <span class="c1">// Largeur du sprite à l'écran</span>
  <span class="n">destination</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">offset_y</span> <span class="o">*</span> <span class="n">zoom</span><span class="p">;</span> <span class="c1">// Hauteur du sprite à l'écran</span>

  <span class="n">destination</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="c1">// La course se fait en milieu d'écran (en vertical)</span>
      <span class="p">(</span><span class="n">window_dimensions</span><span class="p">.</span><span class="n">h</span> <span class="o">-</span> <span class="n">destination</span><span class="p">.</span><span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

  <span class="n">SDL_Event</span> <span class="n">event</span><span class="p">;</span>
  <span class="n">SDL_bool</span> <span class="n">program_on</span> <span class="o">=</span> <span class="n">SDL_TRUE</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">program_on</span><span class="p">)</span>
  <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">))</span>
    <span class="p">{</span> <span class="c1">// Tant que la file des évènements stockés n'est pas vide et qu'on n'a pas</span>
      <span class="c1">// terminé le programme Défiler l'élément en tête de file dans 'event'</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
      <span class="p">{</span>                         <span class="c1">// En fonction de la valeur du type de cet évènement</span>
      <span class="k">case</span> <span class="n">SDL_QUIT</span><span class="p">:</span>            <span class="c1">// Un évènement simple, on a cliqué sur la x de la // fenêtre</span>
        <span class="n">program_on</span> <span class="o">=</span> <span class="n">SDL_FALSE</span><span class="p">;</span> <span class="c1">// Il est temps d'arrêter le programme</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">SDL_KEYDOWN</span><span class="p">:</span> <span class="c1">// Le type de event est : une touche appuyée</span>
                        <span class="c1">// comme la valeur du type est SDL_Keydown, dans la partie 'union' de</span>
                        <span class="c1">// l'event, plusieurs champs deviennent pertinents</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">keysym</span><span class="p">.</span><span class="n">sym</span><span class="p">)</span>
        <span class="p">{</span>        <span class="c1">// la touche appuyée est ...</span>
        <span class="nl">default:</span> <span class="c1">// Une touche appuyée qu'on ne traite pas</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>

    <span class="n">AffichageTextureFenetreComplete</span><span class="p">(</span><span class="n">fond</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">renderer</span><span class="p">);</span>
    <span class="n">AnimationImage</span><span class="p">(</span><span class="n">nuage</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">renderer</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">destination</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>   <span class="c1">// Position en x pour l'affichage du sprite</span>
    <span class="n">state</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">offset_x</span><span class="p">;</span> <span class="c1">// On passe à la vignette suivante dans l'image</span>
    <span class="n">state</span><span class="p">.</span><span class="n">x</span> <span class="o">%=</span> <span class="n">source</span><span class="p">.</span><span class="n">w</span><span class="p">;</span> <span class="c1">// La vignette qui suit celle de fin de ligne est</span>
    <span class="c1">// celle de début de ligne</span>
    <span class="n">SDL_RenderCopy</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">my_texture</span><span class="p">,</span> <span class="c1">// Préparation de l'affichage</span>
                   <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
                   <span class="o">&amp;</span><span class="n">destination</span><span class="p">);</span>

    <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>

    <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// Petite pause</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id='video-9'>Vidéo</h3>
<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/kCX8HTbOmO4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h1 id='jeu-de-la-vie'>Jeu de la vie</h1><h2 id='principe-implemente'>Principe implémenté</h2>
<p>Nous avons implémenté un jeu de la vie en mode &quot;limite&quot; et en mode Tor.
Au démarage on clique sur les cases de l&#39;écran que l&#39;on souhaite mettre en cellule vivante.</p>

<p>Durant la préparation on peut cliquer sur:</p>

<ul>
<li><strong>w</strong> : pour enregistrer la dernière configuration</li>
<li><strong>x</strong> : pour charger la dernière configuration</li>
<li><strong>v</strong> : pour Clear le tableau et supprimer toute les cellules vivantes</li>
</ul>

<p>On démarre la simulation avec <strong>SPACE</strong>.</p>

<p>A tout moment durant la simulation on peut cliquer sur <strong>c</strong> pour changer le mode et sur la flèche de droite ou de gauche pour accélèrer ou ralentir la simulation !</p>

<p>On détecte à chaque itération si on a pas stagné et que plus rien ne bouge !</p>

<p>Les masques de vie et de mort sont très facilement modifiables dans le code et les règles sont visibles graphiquement sur la fenêtre SDL en haut !</p>
<h2 id='probleme-rencontre'>Problème rencontré</h2>
<p>Nous avons recontré un problème que nous avons solutionné comme nous allons vous l&#39;expliquer plus bas.</p>
<h3 id='explication'>Explication</h3>
<p>On a voulu faire une taille de fenêtre responsive mais lorsque l&#39;on fait cela on rencontre des problèmes car pour tracer la grille du jeu on divise la fenetre par le nombre de case de notre tableau C.
A cette étape si la fenêtre n&#39;est pas divisible par le nombre de case du tableau alors on fait des arrondis et un enchaînement d&#39;arrondis de calculs provoque le fait que le damier ne couvre pas toute la fenêtre !</p>

<p style="text-align: center;"><img style="width: 80%" src="images/erreurVie-c338ac79.png"/></p>
<h3 id='solution'>Solution</h3>
<p>On pose une taille de fenêtre fixe au démarrage (800x825 car 25 px pour le menu) et on divise la fenêtre par le nombre de case du tableau en s&#39;assurant que le nombre de case est un diviseur de 800.</p>
<h2 id='video-10'>Video</h2>
<p>Voici une démonstration vidéo de notre programme</p>

<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/JhQonr1lVa0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h1 id='chef-d-39-oeuvre'>Chef d&#39;oeuvre</h1><h2 id='presentation'>Présentation</h2>
<p>Nous avons codé une version améliorée du fameux <strong>Snake</strong>. Dans celui-ci, le but n&#39;est plus seulement de manger toutes les pommes mais aussi de survivre le plus longtemps possible ! En effet le score est lié au temps qui s&#39;écoule durant la partie. Pour forcer l&#39;utilisateur à jouer avec les pommes on a mis un multiplicateur de points à chaque seconde en fonction de la taille du serpent. De plus, ce dit serpent possède plusieurs états tels que &quot;rapide&quot;, &quot;très rapide&quot; ou encore endromi. Le choix de l&#39;état de notre serpent est choisi selon <strong>une chaine de Markov</strong> à chaque fois que le serpent mange une pomme !</p>

<p>Les règles ont été créées par Bertrand. Les voici:</p>

<table><thead>
<tr>
<th></th>
<th>Classique</th>
<th>Lent</th>
<th>Rapide</th>
<th>Très rapide</th>
<th>Endormi</th>
</tr>
</thead><tbody>
<tr>
<td>Classique</td>
<td>0.4</td>
<td>0.1</td>
<td>0.3</td>
<td>0.15</td>
<td>0.05</td>
</tr>
<tr>
<td>Lent</td>
<td>0.5</td>
<td>0.15</td>
<td>0.25</td>
<td>0</td>
<td>0.1</td>
</tr>
<tr>
<td>Rapide</td>
<td>0.14</td>
<td>0.03</td>
<td>0.5</td>
<td>0.3</td>
<td>0.03</td>
</tr>
<tr>
<td>Très rapide</td>
<td>0.08</td>
<td>0.07</td>
<td>0.15</td>
<td>0.2</td>
<td>0.6</td>
</tr>
<tr>
<td>Endormi</td>
<td>0</td>
<td>0.3</td>
<td>0</td>
<td>0</td>
<td>0.7</td>
</tr>
</tbody></table>

<p>On a essayé de donner un sens à ces valeurs</p>

<p>Nous avons essayé de modéliser la matrice de Markov telle que   :
lorsque le serpent mange une pomme, il a une bonne chance de rester à la même vitesse ou de passer à la vitesse supérieur (pour rendre le jeu plus dure puisque le but n&#39;est pas de finir le snake mais de tenir le plus longtemps) et en suivant la logique de la digestion, si il est rapide alors il a mangé beaucoup de pommes et donc il doit digérer donc il a aussi une chance de s&#39;endormir qui augmente avec la vitesse. Lorsqu&#39;il se réveille le serpent est un peu encore endormi donc il passe forcement à la plus petite vitesse.</p>

<p>On enregistre le meilleur score dans un fichier pour les futures exécutions.</p>

<p>Nous nous sommes séparés les tâches par personnes:</p>

<ul>
<li>Lilian a géré toute la partie graphique</li>
<li>Bertrand et Charlotte ont géré tous les algorithmes de déplacement du serpents dans le tableau et liés aux chaines de Markov.</li>
<li>Nous nous sommes aidés les uns les autres sur certains points quand un de nos camarades commencait à peiner.</li>
</ul>
<h2 id='video-11'>Vidéo</h2>
<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/NMooU7Xmg0M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id='a-ameliorer'>A améliorer</h2>
<p>Voici quelques idées de choses à améliorer sur notre projet si nous avions eu plus de temps:</p>

<ul>
<li>Rajouter des murs de manières aléatoires si le joueur ne ramasse pas de pomme</li>
<li>Permettre de rejouer après une défaite</li>
<li>Rajouter un sprite de tête pour le serpent</li>
</ul>
<h1 id='jeu-avec-apprentissage-par-renforcement'>Jeu avec apprentissage par renforcement</h1><h2 id='presentation-2'> Présentation</h2>
<p>Nous avons repris notre jeu <strong>Snake</strong>, le but ici était donc d&#39;apprendre au serpent à se déplacer tout seul et à survivre le plus longtemps pour avoir le meilleur score.</p>
<h2 id='amelioration-de-la-partie-graphique-et-du-quot-gameplay-quot'>Amélioration de la partie graphique et du &quot;GamePlay&quot;</h2>
<p>Nous avons d&#39;abord commencé par reprendre les idées d&#39;amélioration que nous avions eu pour notre jeu de départ.</p>
<h3 id='positionnement-de-cactus'>Positionnement de cactus</h3>
<p>Nous avons rajouté des placements de cactus aléatoire entre chaque pomme prise, dès que le serpent prend une pomme tous les cactus posés disparaissent. Ceci permet de forcer l&#39;utilisateur à prendre des pommes plutôt que de &quot;tourner en rond&quot; pour gagner du temps. Pour cela, nous générons un nombre aléatoire compris entre 0 et le nombre de cases disponibles sur le plateau. Ensuite, nous parcourons le plateau en &quot;sautant&quot; les cases où il y a déjà une pomme ou le serpent jusqu&#39;à tomber sur le nombre aléatoire tiré. Nous posons alors le cactus à cet endroit. </p>
<h3 id='serpent-et-decor'>Serpent et décor</h3>
<p>Ensuite nous avons amélioré la partie graphique en rajoutant un sprite sur tout le corps du serpent, en modifiant le fond, les bordures et les cactus. 
Pour le serpent, nous avons commencé par modéliser sa tête. A chaque fois que l&#39;on change de vitesse, la tête du serpent change. Elle dépend aussi de la direction que le serpent prend. Par exemple, si le serpent va vers le haut, la tếte va regarder vers le haut. Pour cela, nous avons juste à connaître la direction.
Pour le reste du serpent, nous avons d&#39;abord modélisé les angles. Pour cela, nous avons regardé le premier mouvement lorsque le serpent tourne : on s&#39;intéresse alors au courant, au précédent et au suivant. D&#39;abord, nous regardons entre le courant et le précédent s&#39;il y a un changement de lignes ou un changement de colonnes. Ensuite nous faisons la même chose entre le courant et le suivant. Ceci permet de différencier les différents cas et donc de savoir à quel moment, nous devons mettre quel sprite. Si nous ne différencions pas tous les cas en passant par le précédent,le courant et le suivant, nous nous retrouvons avec des angles qui sont indissociables.
Pour le reste du corps, nous avons juste à savoir si le serpent change de colonnes ou de lignes. On raisonne de la même façon que pour les angles en regardant les itérations courantes, précédentes et suivantes. </p>

<p>Pour la partie décor, nous avons parcouru le plateau afin de mettre tout autour des bordures à l&#39;aide de sprite de rochers et en fond un sprite orange qui s&#39;anime et qui fait effet de &quot;sable&quot; qui bougent.</p>
<h3 id='menu'>Menu</h3>
<p>Nous avons ensuite créé un menu afin de permettre à l&#39;utilisateur de pouvoir plus tard choisir entre le mode classique et le mode IA. Ce menu permet aussi au joueur de relancer une partie sans avoir à quitter le jeu.</p>
<h3 id='algorithme'>Algorithme</h3>
<p>La dernière amélioration la plus importante est celle qui correspond à la gestion du serpent et de ses déplacements. Nous sommes passés d&#39;un tableau à une file. Cette amélioration permet de ne plus avoir à faire un décalage droite de tout le tableau (ce qui est coûteux) lorsque le serpent se déplace. A la place, nous avons juste à connaître la place de la tête du serpent dans la file afin de la déplacer dans la file et d&#39;entrer ses nouvelles coordonnées. Ainsi à chaque itération on enfile la nouvelle tête et on défile la queue si le serpent n&#39;a pas mangé. Si il a mangé, on ne déile par la la taille grandit !</p>
<h2 id='apprentissage-par-renforcement-n-1'>Apprentissage par renforcement n°1</h2><h3 id='introduction'>Introduction</h3>
<p>Nous avons tout d&#39;abbord implémenté un premier apprentissage avec seulement la perception de la tête du serpent et la position de la pomme.</p>
<h3 id='explication-et-theorie'>Explication et théorie</h3>
<p>Pour nous, l&#39;apprentissage se fait de telle manière; il apprend tant qu&#39;il n&#39;est pas mort et tant qu&#39;on a pas atteint la limite d&#39;apprentissage à chaque partie. En premier, nous avons implémenté l&#39;apprentissage uniquement sur la partie détection de pomme. Pour cela, le serpent devait regarder où la pomme se trouvait par rapport à lui. Les états sont composés de Nord (1), même ligne (0), Sud(-1), Ouest(1), même colonne(0) et Est (-1). Les actions sont elles de la forme : Haut, Bas, Droite et Gauche. La QTable utilisée pour ce cas initialement, implémentée par Bertrand, est donc de cette forme :</p>

<table><thead>
<tr>
<th>Etats/Actions</th>
<th>Haut(0)</th>
<th>Bas(1)</th>
<th>Droite(2)</th>
<th>Gauche(3)</th>
</tr>
</thead><tbody>
<tr>
<td>Etat 0 : Sud-Est (-1,-1)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr>
<td>Etat 1 : Sud (-1,0)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr>
<td>Etat 2 : Sud-Ouest (-1,1)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr>
<td>Etat 3 : Est (0,1)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr>
<td>Etat 4 : Sur la pomme (0,0)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr>
<td>Etat 5 : Ouest (0,1)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr>
<td>Etat 6 : Nord-Est (1,-1)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr>
<td>Etat 7 : Nord (1,0)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr>
<td>Etat 8 : Nord-Ouest (1,1)</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
</tr>
</tbody></table>

<p>Cette QTable évolue donc au fil des parties grâce aux mouvements du serpent.</p>
<h3 id='algorithmes'>Algorithmes</h3>
<p>Pour implémenter l&#39;apprentissage par renforcement, nous avons eu besoin en premier de faire le lien entre le serpent et la pomme : savoir où se trouve la pomme par rapport au serpent. Pour cela, nous avions besoin de la position de la tête du serpent et la pomme. A partir de ces positions, on calcule les différences entre les coordonnées (xS,yS) du serpent et (xP,yP) de la pomme. Selon les signes de ces différences, on peut savoir si la pomme se trouve à l&#39;est ou l&#39;ouest et au nord ou au sud et c&#39;est à partir de ces signes, que l&#39;on peut savoir dans quel état actuel est le serpent.</p>

<p>Ensuite, nous avons implémenter le lien entre l&#39;état dans lequel le serpent est et l&#39;action futur qu&#39;il va faire. Cette fonction utilise donc la QTable. On regarde alors la ligne dans le tableau qui correspond à l&#39;état du serpent. A partir de cette ligne, on cherche le coefficient maximal, ce coefficient va alors correspondre à la future action du serpent.</p>

<p>La plus grande partie de notre algorithme se compose ensuite de deux parties : exploration et exploitation du serpent.
Pour la partie exploration, </p>
<h3 id='video-de-l-39-apprentissage-par-renforcement-n-1'>Vidéo de l&#39;apprentissage par renforcement n°1</h3>
<p style="text-align: center;"><iframe width="80%" height="315" src="https://www.youtube.com/embed/xOpty5HOP7U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id='apprentissage-par-renforcement-n-2'>Apprentissage par renforcement n°2</h2><h3 id='introduction-2'>Introduction</h3>
<p>Nous avons décidé d&#39;améliorer l&#39;apprentissage par renforcement en faisant que le serpent percoit ce qu&#39;il se passe autour de lui et ainsi évite de se tuer en se touchant ou en touchant un obstacle (cactus par exemple).</p>
<h3 id='explication-et-theorie-2'>Explication et théorie</h3>
<p>Après avoir fait cette première implémentation, le serpent n&#39;avait pas la conscience de lui même. Nous avons donc améliorer l&#39;apprentissage en lui apprenant à avoir conscience de son corps mais aussi des cactus et des bordures. Pour lui, son corps, les cactus et les bordures sont des éléments qui vont le tuer donc il doit les éviter. Pour cela, nous regardons si autour de la tête du serpent (en haut, en bas, à gauche, à droite), il y a un des trois éléments cités avant (mur, cactus, lui même). La QTable prend alors trois dimensions : les états liés à la pomme, les actions et la perception de ce qui l&#39;entoure.
Le principe du code reste alors le même c&#39;est juste la QTable qui a changé.</p>
<h3 id='schema-de-representation-des-etats-du-code-et-des-fichiers-utilises'>Schéma de Représentation des états du code et des fichiers utilisés</h3>
<p style="text-align: center;"><img style="width: 80%" src="images/schemacode-64609a55.png"/></p>
<h3 id='representation-de-la-qtable'>Représentation de la QTABLE</h3>
<p style="text-align: center;"><img style="width: 80%" src="images/qtable-2a429000.png"/></p>
<h3 id='video-de-l-39-apprentissage-par-renforcement-n-2'>Vidéo de l&#39;apprentissage par renforcement n°2</h3>
      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="c">c</a>
          </div>
      </div>
    </div>
  </body>
</html>
